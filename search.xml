<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cpp对象模型:构造解构语义学</title>
      <link href="/cpp%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/2021-01-21-3%E6%9E%84%E9%80%A0%E8%A7%A3%E6%9E%84%E8%AF%AD%E4%B9%89%E5%AD%A6/"/>
      <url>/cpp%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/2021-01-21-3%E6%9E%84%E9%80%A0%E8%A7%A3%E6%9E%84%E8%AF%AD%E4%B9%89%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>考虑下面的abstract base class声明</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Abstract_base</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Abstract_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// pure virtual function </span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">virtual</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">mumble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _mumble<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">char</span><span class="token operator">*</span> _mumble<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </code></pre><span id="more"></span><p>以上代码问题如下</p><ol><li>尽管Abstract_base为抽象的base class，有pure virtual function因而不可能拥有实体。但仍然需要一个明确的构造函数对_mumble进行初始化。 </li><li>将析构函数设置为纯虚数，但Abstract_base仍然需要定义它。因为derived class destructor会被编译器扩展，以静态调用形式调用base destructor。若Abstract_base声明为纯虚数且未定义，则会导致析构链接失败 </li></ol><pre class="language-cpp" data-language="cpp"><code class="language-cpp">        <span class="token comment">// 需要对virtual ~Abstract_base进行定义实现 </span>    <span class="token class-name">Abstract_base</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Abstract_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>  ```    一般的， <span class="token operator">*</span><span class="token operator">*</span>不要把<span class="token keyword">virtual</span> destructor声明为pure <span class="token keyword">virtual</span><span class="token operator">*</span><span class="token operator">*</span>  <span class="token number">1.</span> 将<span class="token keyword">virtual</span> interface声明为<span class="token keyword">const</span>，而derived instance很可能修改其中一个member， <span class="token operator">*</span><span class="token operator">*</span>尽量不要对<span class="token keyword">virtual</span> function声明为<span class="token keyword">const</span><span class="token operator">*</span><span class="token operator">*</span>  <span class="token number">2.</span> mumble不应该声明为<span class="token keyword">virtual</span>，函数一般不会被derived <span class="token keyword">class</span>重写，没必要声明为<span class="token keyword">virtual</span>。 修改后代码如下```cpp        <span class="token keyword">class</span> <span class="token class-name">Abstract_base</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span><span class="token operator">:</span>         <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Abstract_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">mumble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _mumble<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 注意函数用const修饰，返回类型为const char*,返回值不能被修改（只能修饰指针） </span>        <span class="token comment">// const char* 只能被const char* p接收 </span>    <span class="token keyword">protected</span><span class="token operator">:</span>         <span class="token function">Abstract_base</span><span class="token punctuation">(</span> <span class="token keyword">char</span><span class="token operator">*</span> pc <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 带参数的constructor </span>        <span class="token keyword">char</span> <span class="token operator">*</span>_mumble<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>          <span class="token comment">// 体会下const return </span>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">integer_return</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 必须传引用，不能传值 </span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>     <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token function">integer_return</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>a <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> </code></pre><h3 id="无继承情况下的对象构造"><a href="#无继承情况下的对象构造" class="headerlink" title="无继承情况下的对象构造"></a>无继承情况下的对象构造</h3><p>考虑程序片段</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">Point global<span class="token punctuation">;</span>  Point <span class="token function">foobar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>     Point local<span class="token punctuation">;</span>     Point <span class="token operator">*</span>heap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">*</span>heap <span class="token operator">=</span> local<span class="token punctuation">;</span>      <span class="token keyword">delete</span> heap<span class="token punctuation">;</span>     <span class="token keyword">return</span> local<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p>以上L1,L5,L6表现出 <strong>三种不同的对象产生方式</strong><br>，global内存配置，local内存配置，heap内存配置。一个object的生命，是object一个执行期属性。local<br>object从L5开始，L10结束。global object声明和整个程序生命相同，heap<br>object生命从new运算符配置出来开始，到delete运算符摧毁为止。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">Point的声明 <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">float</span> x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>Point<span class="token punctuation">;</span> </code></pre><p>C++将以上C风格程序称之为Plain Of Data形式。在编译时，编译器会分析这个声明，贴上Plain Of Data标签。</p><p>当执行Point global时，程序一如在C表现一样。一般的trivial default constructor, trivial<br>destructor, trivial copy constructor, trivial copy assignment<br>operator等未被定义或调用（不是所有情况都会生成以上trivial member，前几篇文章有说）</p><p>C和C++一个差异是，C++所有全局对象都被当作初始化的数据对待。</p><p>L5中Point object local,同样没有生成default constructor，而是当作C中的struct操作，即Plain Of<br>Data。但需要进行赋初值。注意 <strong>如果写了constructor，自然通过C++构造函数来进行构造。</strong></p><p>L6转化如下</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">Point <span class="token operator">*</span>heap <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">;</span> <span class="token comment">// 转化为 </span>Point <span class="token operator">*</span>heap <span class="token operator">=</span> <span class="token function">__new</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Point<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>但仍然没有default施行于new运算符返回的Point object身上。同样对于赋值，由于object是一个Plain Of<br>Data,赋值操作只是像C那样纯粹位搬移操作。</p><p>总之，在 <strong>无构造函数，无继承，无虚函数，C++类和C的struct操作无太大区别</strong> 。不论private、public存取层，或是member<br>function的声明，都不会占用额外的对象空间。</p><p>对class所有成员设定常量初值，给予一个 <strong>explicit initialization list</strong> 会比较高效，甚至在local scope<br>，如下</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mumble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     Point local1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     Point local2<span class="token punctuation">;</span>     <span class="token comment">// 下列相当于inline expansion, local1比local2快 </span>    local2<span class="token punctuation">.</span>_x <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>     local2<span class="token punctuation">.</span>_y <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>     local2<span class="token punctuation">.</span>_z <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p>Explicit initialization list的缺点</p><ol><li>只能指定常量，因为编译期可以求值 </li><li>初始化失败可能性较高 </li></ol><p>编译器内部有识别inline expansion并进行explicit initialization list优化的功能。</p><h4 id="Virtual-function的引入"><a href="#Virtual-function的引入" class="headerlink" title="Virtual function的引入"></a>Virtual function的引入</h4><p>以下列程序为例</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Point</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span>         <span class="token operator">:</span> <span class="token function">_x</span><span class="token punctuation">(</span> x <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_y</span><span class="token punctuation">(</span> y <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span>     <span class="token comment">// no destructor, copy constructor, copy operator defined </span>    <span class="token keyword">virtual</span> <span class="token keyword">float</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">float</span> _x<span class="token punctuation">,</span> _y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p>Virtual function的引入促使每一个object拥有一个virtual table pointer。除了每一个class<br>object多负担一个vptr之外，也引发class的膨胀。</p><ol><li><p>定义的constructor被扩展，以便<strong>将vptr初始化</strong>, 构造函数不能是虚函数, 因为虚函数的调用需要虚函数指针vptr(对象函数的调用需要this指针), 构造函数如果为虚函数此时没有虚函数指针，构造函数无法被调用。</p></li><li><p>合成一个copy constructor和一个copy assignment operator,而且其操作不再是trivial( implicit destructor仍然是trivial)。一般的，将rhs的连续位拷贝给this对象，之后return this。这种default copy constructor可能存在问题。 </p></li></ol><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 内部膨胀 </span>Point<span class="token operator">*</span> <span class="token class-name">Point</span><span class="token double-colon punctuation">::</span><span class="token function">Point</span><span class="token punctuation">(</span> Point<span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//  设置object的virtual table pointer( vptr ） </span>    <span class="token keyword">this</span><span class="token operator">-></span>__vptr_Point <span class="token operator">=</span> __vtbl_Point<span class="token punctuation">;</span>     <span class="token comment">//  扩展member initialization list </span>    <span class="token keyword">this</span><span class="token operator">-></span>_x <span class="token operator">=</span> x<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token operator">-></span>_y <span class="token operator">=</span> y<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p>引入virtual function时将合成default constructor，这也导致当对象赋值，return object时候 <strong>会出现copy<br>constructor的过程</strong> ，而不再是像C语言那样位搬移操作。</p><h3 id="继承情况下的对象构造"><a href="#继承情况下的对象构造" class="headerlink" title="继承情况下的对象构造"></a>继承情况下的对象构造</h3><p>当我们定义一个object, T object。</p><p>如果T有一个constructor(不论是user<br>提供还是编译器合成），constructor会被调用。而且编译器会扩充每一个constructor，扩充程度视class T的继承体系而定。一般而言，<br><strong>编译器所做的扩充</strong> 大约如下</p><ol><li>记录member initialization list中的data members初始化操作，并以member的声明顺序为初始化顺序 </li><li>若有一个member没有出现在member initialization list之中，但它有一个default constructor，则该default constructor必须被调用 </li><li>在1,2之前，若class object有virtual table pointer，它必须设置初值，指向合适的virtual table </li><li>在1,2,3之前，上一层的base class constructor必须被调用 <strong>(先构建base class)</strong> 。若class列在member initialization list，直接调用之。将生成默认initialization list调用之。对虚拟继承，class中的每一个virtual base class subobject的偏移量必须在执行期内存取。 </li></ol><pre class="language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span>     <span class="token keyword">public</span><span class="token operator">:</span>         <span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token function">Base</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct derive class"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>     <span class="token comment">// 以上将调用Base()而不是Base(2)进行构造，因为默认生成Derive():Base()&#123;&#125;，写在constructor内部没有构造作用 </span>    <span class="token keyword">class</span> <span class="token class-name">Derive</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">&#123;</span>     <span class="token keyword">public</span><span class="token operator">:</span>         <span class="token function">Derive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">this</span><span class="token operator">-></span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>     <span class="token comment">// 尽管调用Base(2)使Base->a = 2，但输出derive->a结果为3 </span>```   例```cpp        <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span><span class="token operator">:</span>         <span class="token function">Point</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">Point</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// copy constructor </span>        Point<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// copy assignment operator </span>             <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// virtual destructor </span>        <span class="token keyword">virtual</span> <span class="token keyword">float</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>     <span class="token keyword">protected</span><span class="token operator">:</span>         <span class="token keyword">float</span> _x<span class="token punctuation">,</span> _y<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>          <span class="token comment">// Line class  </span>    <span class="token keyword">class</span> <span class="token class-name">Line</span> <span class="token punctuation">&#123;</span>         Point _begin<span class="token punctuation">,</span> _end<span class="token punctuation">;</span>     <span class="token keyword">public</span><span class="token operator">:</span>         <span class="token function">Line</span><span class="token punctuation">(</span> <span class="token keyword">float</span><span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">=</span><span class="token number">0.0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">Line</span> <span class="token punctuation">(</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>          每一个<span class="token keyword">explicit</span> constructor都会被扩充，以调用其两个member Point object的constructor     <span class="token comment">// 定义Line constructor  </span>    <span class="token class-name">Line</span><span class="token double-colon punctuation">::</span><span class="token function">Line</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> begin<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> end<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_end</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_begin</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>          <span class="token comment">// 被编译器扩充为 </span>    Line<span class="token operator">*</span> <span class="token class-name">Line</span><span class="token double-colon punctuation">::</span><span class="token function">Line</span><span class="token punctuation">(</span>Line <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>begin<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> end<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>         <span class="token keyword">this</span><span class="token operator">-></span>_begin<span class="token punctuation">.</span><span class="token class-name">Point</span><span class="token double-colon punctuation">::</span><span class="token function">Point</span><span class="token punctuation">(</span> begin <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token operator">-></span>_end<span class="token punctuation">.</span><span class="token class-name">Point</span><span class="token double-colon punctuation">::</span><span class="token function">Point</span><span class="token punctuation">(</span> end <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> </code></pre><p>当写下Line a， implicit Line destructor会被合成出来（若Line派生Point，则合成virtual<br>destructor，但本例Line只是内带Point objects而非继承，所以只需合成nontrivial<br>destructor)，会调用其member object的destructor。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">Line</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Line</span><span class="token punctuation">(</span> Line <span class="token operator">*</span><span class="token keyword">this</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">this</span><span class="token operator">-></span>_end<span class="token punctuation">.</span><span class="token class-name">Point</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token operator">-></span>_begin<span class="token punctuation">.</span><span class="token class-name">Point</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p>写下 Line b = a, implicit Line copy constructor会被合成出来，成为一个inline public member</p><p>写下a = b, implicit copy assignment operator会被合成出来，成为一个inline public member。</p><p>注意在写copy operator时</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 添加如下条件句筛选 </span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>     <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 否则可能会做多余拷贝工作，如下 </span>Line p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> Line p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>  <span class="token comment">//而且需要注意释放资源筛选 </span>String<span class="token operator">&amp;</span> String<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span> <span class="token keyword">const</span> String <span class="token operator">&amp;</span>rhs <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>     <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">;</span>   <span class="token comment">//前面如果不加条件筛选，有可能this == rhs，直接把两个都delete了。 </span>    str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span> <span class="token function">strlen</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>str<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>考虑虚拟继承</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token keyword">class</span> <span class="token class-name">Point3d</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">Point</span></span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span><span class="token operator">:</span>         <span class="token function">Point3d</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> z <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span>             <span class="token operator">:</span> <span class="token function">Point</span><span class="token punctuation">(</span> x<span class="token punctuation">,</span> y <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_z</span><span class="token punctuation">(</span> z <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>         <span class="token function">Point3d</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Point3d<span class="token operator">&amp;</span> rhs <span class="token punctuation">)</span>             <span class="token operator">:</span> <span class="token function">Point</span><span class="token punctuation">(</span> rhs <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_z</span><span class="token punctuation">(</span> rhs<span class="token punctuation">.</span>_z <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>         <span class="token operator">~</span><span class="token function">Point3d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Point3d<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Point3d<span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">virtual</span> <span class="token keyword">float</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _z <span class="token punctuation">&#125;</span>           <span class="token keyword">protected</span><span class="token operator">:</span>          <span class="token keyword">float</span> _z<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> ```    虚拟继承不同在于，虚基类不会被所有子类初始化，而只会被最终的派生类初始化。  <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token operator">:</span><span class="token comment">//pic2.zhimg.com/v2-e55be8f6363be46dfab76072771adfed_b.jpg)</span>  以上， <span class="token operator">*</span><span class="token operator">*</span>Vertex3d有责任将Point初始化<span class="token operator">*</span><span class="token operator">*</span> 。而Point3d和Vertex同为Vertex3d的subobjects，它们都不能对Pointconstructor进行调用。```cpp         <span class="token comment">// Vertex3d的constructor扩充内容 </span>    Vertex3d<span class="token operator">*</span>     <span class="token class-name">Vertex3d</span><span class="token double-colon punctuation">::</span><span class="token function">Vertex3d</span><span class="token punctuation">(</span> Vertex3d <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> __most_derived<span class="token punctuation">,</span> <span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z <span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>         <span class="token comment">//  根据提条件决定是否调用Base class Point </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>__most_derived <span class="token operator">!=</span> <span class="token boolean">false</span> <span class="token punctuation">)</span>             <span class="token keyword">this</span> <span class="token operator">-></span> <span class="token class-name">Point</span><span class="token double-colon punctuation">::</span><span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 调用上一层的base class </span>        <span class="token comment">// 设置false表示Point3d Vertex均不能调用Point constructor,只有Vertex3d可以。 </span>        <span class="token comment">// 如果不是虚拟继承，则相反。Vertex3d不能调用Point, Pointe3d Vertex可以 </span>        <span class="token keyword">this</span> <span class="token operator">-></span> Point3d<span class="token operator">:</span><span class="token function">Point3d</span><span class="token punctuation">(</span> <span class="token boolean">false</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span> <span class="token operator">-></span> <span class="token function">Vertex</span><span class="token punctuation">(</span> <span class="token boolean">false</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 设定vptrs; </span>        <span class="token comment">// 安插user code </span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> </code></pre><p>注意到当定义 Point3d origin;时，Point3d会先调用Point。而定义Vertex3d<br>cv;时，Point3d只是cv的subobject，Point3d不会调用Point constructor。</p><p>因此有的编译器将constructor分成两种情况，一种接收完整object（如Point3d<br>origin），一种则接收subobject（如Vertex3d cv）。完整object版无条件调用virtual base<br>constructor，设定vptrs；subobject版则不调用virtual base constructors，也可能不调用vptrs。</p><p>Constructor的调用顺序是： <strong>由根源到末端，由内而外</strong> 。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 定义一个Pertex object时，constructor的调用顺序是 </span><span class="token function">Point</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">Point3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">Vertex</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">Vertex3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">PVertex</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>当base class constructor执行时，derived实体还没有构造出来。Point3d constructor执行之后，只有Point3d<br>subobject构造完毕。</p><p>这种机制要求， <strong>每一个调用操作以静态方式</strong> ，原因很简单，derived object还没有构造，谈不上动态绑定，只能用base<br>object的member。</p><p><strong>constructor的执行流程</strong> 如下</p><ol><li>在derived class constructor中，所有virtual base class 及上一层base class的constructor会被调用 </li><li>上述操作完成后，对象的vptr被初始化，指向相关的virtual tables </li><li>如果有 member initialization list的话，将在constructor体内扩展。这必须在vptr被设定之后，因为有可能会调用virtual function。 </li><li>最后执行程序员编写的代码 </li></ol><p>例 定义的PVertex constructor</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">PVertex<span class="token operator">:</span><span class="token function">PVertex</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z <span class="token punctuation">)</span>     <span class="token operator">:</span> <span class="token function">_next</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Vertex3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span> spyOn <span class="token punctuation">)</span>         cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Within Pertex::Pertex() "</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"size: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">//  被扩展为 </span>Pertex<span class="token operator">*</span> <span class="token function">Pertex</span><span class="token punctuation">(</span> PVertex<span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> __most__derived<span class="token punctuation">,</span> <span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 条件地调用virtual base constructor </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> __most__derived <span class="token operator">!=</span> <span class="token boolean">false</span> <span class="token punctuation">)</span>         <span class="token keyword">this</span> <span class="token operator">-></span> <span class="token class-name">Point</span><span class="token double-colon punctuation">::</span><span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 无条件的调用上一层base </span>    <span class="token keyword">this</span> <span class="token operator">-></span> <span class="token class-name">Vertex3d</span><span class="token double-colon punctuation">::</span><span class="token function">Vertex3d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 将相关vptr初始化 </span>    <span class="token keyword">this</span><span class="token operator">-></span>__vptr_Pertex <span class="token operator">=</span> __vtbl_PVertex<span class="token punctuation">;</span>     <span class="token keyword">this</span> <span class="token operator">-></span> __vptr_Point_PVertex <span class="token operator">=</span> __vtbl_Point_PVervex<span class="token punctuation">;</span>      <span class="token comment">//  程序员写的码 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> spyOn <span class="token punctuation">)</span>         cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Within Pertex::Pertex() "</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"size: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token operator">-></span>__vptr__PVertex<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>faddr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p>Destruction步骤与Constructor相反</p><ol><li>destructor的函数本身先执行 </li><li>如果class有member class objects, 后者拥有destructors，那么 <strong>以声明相反顺序调用</strong></li><li>若object内含vptr，则重新设定，指向适当的base class的virtual table </li><li>若nonvirtual base class拥有destructor，按声明相反顺序调用 </li><li>若virtual base class 拥有destructor，按声明相反顺序调用。 </li></ol><pre><code class="cpp">    举例      #include&lt;iostream&gt;     using namespace std;          class D&#123;     public:         D()&#123;cout&lt;&lt;&quot;D Constructor\n&quot;;&#125;         ~D()&#123;cout&lt;&lt;&quot;D Destructor\n&quot;;&#125;     &#125;;      class C : public virtual D&#123;         public:             C()&#123;cout&lt;&lt;&quot;C Constructor\n&quot;;&#125;             ~C()&#123;cout&lt;&lt;&quot;C Destructor\n&quot;;&#125;     &#125;;     class B : public virtual D&#123;         public:             B()&#123;cout&lt;&lt;&quot;B Constructor\n&quot;;&#125;             ~B()&#123;cout&lt;&lt;&quot;B Destructor\n&quot;;&#125;          &#125;;     class A:public C,public B     &#123;         public:             A()&#123;cout&lt;&lt;&quot;A Constructor\n&quot;;&#125;             ~A()&#123;cout&lt;&lt;&quot;A Destructor\n&quot;;&#125;          &#125;;     int main()&#123;         A a;         return 0;     &#125;     // 结果；     // Constrctor执行与Destructor完全相反     D Constructor     C Constructor     B Constructor     A Constructor     A Destructor     B Destructor     C Destructor     D Destructor </code></pre><p>当设计一个class，并以一个class object指定给另一个class object时，有三种选择</p><ol><li>什么都不做，默认复制行为 </li><li>提供一个explicit copy assignment operator </li><li>明确拒绝一个class object指定给另一个class object，只要将copy assignment operator <strong>声明为private</strong> ，编译器即不能调用。 </li></ol><p>一般的，由bitwise copy完成，期间没有copy assignment operator被调用。以下情况不会出现bitwise<br>copy，而会产生copy assignment operator</p><ol><li>class内含一个object，该object的class有一个copy assignment operator </li><li>Class base class有copy assignment operator </li><li>当class声明了virtual fucntion，需要使用copy assignment operator处理vptr </li><li>当class继承自一个virtual base class，同样有虚类表。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> cpp对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp对象模型:Data和function</title>
      <link href="/cpp%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/2021-01-18-2Data%E5%92%8Cfunction/"/>
      <url>/cpp%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/2021-01-18-2Data%E5%92%8Cfunction/</url>
      
        <content type="html"><![CDATA[<blockquote><p>C++中的Data语义</p></blockquote><h2 id="Data语义学"><a href="#Data语义学" class="headerlink" title="Data语义学"></a>Data语义学</h2><h3 id="Data-Member"><a href="#Data-Member" class="headerlink" title="Data Member"></a>Data Member</h3><p>Data members的布局</p><span id="more"></span><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point3d</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token comment">// ... </span><span class="token keyword">private</span><span class="token operator">:</span>     <span class="token keyword">float</span> x<span class="token punctuation">;</span>     <span class="token keyword">static</span> List<span class="token operator">&lt;</span>Point3d<span class="token operator">*</span><span class="token operator">></span> <span class="token operator">*</span>freeList<span class="token punctuation">;</span>     <span class="token keyword">float</span> y<span class="token punctuation">;</span>     <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> chunksize <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>     <span class="token keyword">float</span> z<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">class_type</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">data_type1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">data_type2</span><span class="token operator">></span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">access_order</span><span class="token punctuation">(</span>data_type1 class_type<span class="token double-colon punctuation">::</span><span class="token operator">*</span>mem1<span class="token punctuation">,</span> data_type2 class_type<span class="token double-colon punctuation">::</span><span class="token operator">*</span>mem2 <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">assert</span> <span class="token punctuation">(</span>mem1 <span class="token operator">!=</span> mem2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> mem1 <span class="token operator">&lt;</span> mem2 <span class="token operator">?</span> <span class="token string">"member 1 occurs first"</span> <span class="token operator">:</span> <span class="token string">"member 2 occurs first"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// class_type会被绑定为Point3d, data_type1 data_type2会被绑定为 float </span><span class="token function">access_order</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>Point3d<span class="token double-colon punctuation">::</span>z<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Point3d<span class="token double-colon punctuation">::</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>以上，Nonstatic data members在class object中的排列顺序和其被声明的顺序一样，即x,y,z。static data<br>members则存放在程序的data segment中，和class objects无关。</p><p>编译器还可能会合成内部使用的data members，例如vptr。</p><h3 id="Static-data-members"><a href="#Static-data-members" class="headerlink" title="Static data members"></a>Static data members</h3><p>Static member只有一个实体，并不在class object之中，存取之不需要通过class object。</p><p>如果两个class，每个都声明了相同名称static member。当它们都放在data<br>segment中会导致名称冲突。编译器的解决办法是对每一个static data member进行编码。</p><p>Nonstatic data member直接存放在每一个class object中，一般的，存取nonstatic data<br>member时。编译器需要把class object的起始地址加上data member的偏移量。</p><h3 id="继承与data-member"><a href="#继承与data-member" class="headerlink" title="继承与data member"></a>继承与data member</h3><p>一般而言，具体继承(concrete inheritance)不会增加空间和时间的额外负担，虚拟继承(virtual<br>inheritance)则会。但设计继承时，应 <strong>尽量避免重复设计相同操作的函数</strong> ，并且选取合适的函数作为inline函数。</p><p>当涉及到多态时，如下所示</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point2d</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token operator">:</span>     <span class="token function">Point2d</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// 加上z的保留空间 </span>    <span class="token keyword">float</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">float</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">void</span> <span class="token function">x</span><span class="token punctuation">(</span> <span class="token keyword">float</span> newX <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> _x <span class="token operator">=</span> newX <span class="token punctuation">&#125;</span>     <span class="token keyword">void</span> <span class="token function">y</span><span class="token punctuation">(</span> <span class="token keyword">float</span> newY <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> _y <span class="token operator">=</span> newY <span class="token punctuation">&#125;</span>      <span class="token keyword">virtual</span> <span class="token keyword">float</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">z</span> <span class="token punctuation">(</span> <span class="token keyword">float</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>      <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Point2d<span class="token operator">&amp;</span> rhs <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         _x <span class="token operator">+=</span> rhs<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         _y <span class="token operator">+=</span> rhs<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">class</span> <span class="token class-name">Point3d</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Point2d</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Point3d</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> z <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span>         <span class="token operator">:</span> <span class="token function">Point2d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token keyword">float</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _z <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token keyword">float</span> <span class="token function">z</span><span class="token punctuation">(</span> <span class="token keyword">float</span> newZ <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>_z <span class="token operator">=</span> newZ<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>     <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Point3d<span class="token operator">&amp;</span> rhs <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         Point2d<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token operator">+=</span> <span class="token punctuation">(</span> rhs <span class="token punctuation">)</span><span class="token punctuation">;</span>         _z <span class="token operator">+=</span> rhs<span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">float</span> _z<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span> Point2d<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> Point2d<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     p1 <span class="token operator">+=</span> p2<span class="token punctuation">;</span>  <span class="token comment">// 显然p1,p2可以为2d坐标点，也可以是3d坐标点 </span><span class="token punctuation">&#125;</span> </code></pre><p>使用virtual带来的额外负担</p><ol><li><p>导入一个和Point2d有关的virtual table，用来存放所声明的virtual function的地址。还要加上几个slot支持runtime type identification </p></li><li><p>每个class object导入一个vptr提供执行期的链接</p></li><li><p>加强constructor，能够为vptr赋初值</p></li><li><p>加强destructor，能够对vptr,vtbl进行析构。</p></li></ol><p>vptr一般放在class object的起头处或者结尾处。</p><h3 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h3><p>从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，可能存在一个基类的多份拷贝，二义性。</p><p>虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）。</p><p>vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual<br>table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员。 <strong>派生类不必存储基类的拷贝，转而以地址代替。</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point2d</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">float</span> _x<span class="token punctuation">,</span> _y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">class</span> <span class="token class-name">Vertex</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">Point2d</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">protected</span><span class="token operator">:</span>      Vertex <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">class</span> <span class="token class-name">Point3d</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">Point2d</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">protected</span><span class="token operator">:</span>      <span class="token keyword">float</span> _z<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">class</span> <span class="token class-name">Vertex3d</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Vertex</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Point3d</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">protected</span><span class="token operator">:</span>      <span class="token keyword">float</span> mumble<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </code></pre><p><img src="https://pic1.zhimg.com/v2-2c7679b2673a6a74dbecff8844f90370_b.jpg" loading="lazy"></p><p>注意到 virtual继承声明在Pointed与Vertex,<br>Point3d之间，Vertex3d与Vertex和Point3d之间不用声明。后者可以通过正常继承得到virtual继承表和指针。</p><p><img src="https://pic4.zhimg.com/v2-a9735a633c8684ded44314c7981e29bf_b.jpg" loading="lazy"></p><p>对比虚函数的实现原理：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）。</p><p>虚基类依旧存在继承类中，只占用存储空间；虚函数不占用存储空间，虚指针占。</p><p>虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。</p><h2 id="Function语意学"><a href="#Function语意学" class="headerlink" title="Function语意学"></a>Function语意学</h2><p>C++支持三种类型的member functions: static, non-static, virtual</p><h3 id="Nonstatic-Member-Functions"><a href="#Nonstatic-Member-Functions" class="headerlink" title="Nonstatic Member Functions"></a>Nonstatic Member Functions</h3><p>C++的设计准则之一就是： nonstatic member function至少和一般的nonmember<br>function有相同的效率。实际上member function会被编译器转化为nonmember形式处理。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 以下来两个函数应该有同等效率</span><span class="token keyword">float</span> <span class="token function">magnitude3d</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Point3d <span class="token operator">*</span>_this<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token keyword">float</span> <span class="token class-name">Point3d</span><span class="token double-colon punctuation">::</span><span class="token function">magnitude3d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token comment">// 以下是member function被内化为nonmember形式的转化步骤</span><span class="token comment">// 1. 安插一个额外的参数到member fucntion中，使class object可以调用该函数。</span>Point3d<span class="token class-name">Point3d</span><span class="token double-colon punctuation">::</span><span class="token function">magnitude</span><span class="token punctuation">(</span> Point3d <span class="token operator">*</span><span class="token keyword">const</span> <span class="token keyword">this</span> <span class="token punctuation">)</span><span class="token comment">// 若member function为const则变成如下，这也说明const修饰后函数不能改变member data</span><span class="token comment">// Point3d *const this 指针指向地址不能变，但指向的对象Point3d可以变。</span><span class="token comment">// const Point3d *const this 指针指向的地址，指向的对象都不能变。</span>Point3d<span class="token class-name">Point3d</span><span class="token double-colon punctuation">::</span><span class="token function">magnitude</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Point3d <span class="token operator">*</span><span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token comment">//2. 对每一个nonstatic data member的存取改为由this指针存取</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">sqrt</span> <span class="token punctuation">(</span>        <span class="token keyword">this</span><span class="token operator">-></span>_x <span class="token operator">*</span> this_x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 3. 将member function重新写成外部函数，函数名称进行mangling处理。</span><span class="token keyword">extern</span> <span class="token function">magnitude_7Point3dFv</span> <span class="token punctuation">(</span>    <span class="token keyword">register</span> Pointe3d <span class="token operator">*</span><span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用时由 obj.magnitude(); 变为 magnitude_7Point3dFv( &amp;obj );</span><span class="token comment">// ptr->magnitude(); 变为 magnitude_7Point3dFv( ptr );</span></code></pre><p>C++为了支持重载，会对function进行mangling，以提供独一无二的名称。</p><p>对nonstatic member function的const修饰实际上是对转化后nonmember function 的obj实参的修饰。</p><h3 id="Static-Member-Functions"><a href="#Static-Member-Functions" class="headerlink" title="Static Member Functions"></a>Static Member Functions</h3><p>如果Point3::normalize()是一个static member function，以下两个调用操作</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">obj<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ptr<span class="token operator">-></span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 转换为一般的nonmember函数调用 </span><span class="token function">normalize_7Point3dSFv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>Static member functions的主要特性就算它没有this指针，以下的次要特性统统源自其主要特性</p><ol><li>不能直接存取class 中的nonstatic members </li><li>不能声明为const, volatile或virtual ，因为以上声明本质是对this指针进行修饰 </li><li>不需要经由class object调用 </li></ol><p>其地址类型并不是“指向class member function的指针”，而是一个 <strong>non member 函数指针，</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token operator">&amp;</span><span class="token class-name">Point3d</span><span class="token double-colon punctuation">::</span><span class="token function">object_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会得到一个数值，类型为 unsigned int (*) (); </span><span class="token comment">// 而不是 unsigned int ( Point3d::*) (); </span></code></pre><p>Static member function由于缺乏this指针，因此差不多等同于nonmember function，成为一个callback函数。</p><h3 id="Virtual-Member-Functions"><a href="#Virtual-Member-Functions" class="headerlink" title="Virtual Member Functions"></a>Virtual Member Functions</h3><p>如果normaliza()是一个virtual member function，那么调用 ptr-&gt;normalize(); 会转化为 (* ptr -&gt;<br>vptr[ 1 ]) ( ptr ); 第二个ptr表示this指针。</p><p>如果magnitude()也是一个virtual function，则</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">register</span> <span class="token keyword">float</span> mag <span class="token operator">=</span> <span class="token function">magnitude</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 转化如下,this指针作为形参 </span><span class="token keyword">register</span> <span class="token keyword">float</span> mag <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token operator">-></span>vptr<span class="token punctuation">[</span> <span class="token number">2</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>执行期多态，以ptr-&gt;z()为例，调用操作需要ptr在执行期的某些相关信息。一种直截了当的办法时把需要的信息加到指针ptr身上，但显然这种方法成本太高。另一种方法是把执行期加到对象本身，也就算通过虚函数和表的方法。</p><p>在C++中，多态(polymorphism)表示，以一个public base class的指针或reference，寻址出一个derived class<br>object。没有使用virtual function称消极多态，反之成为积极多态。</p><p>一个class只会有一个virtual table，每一个table内含其对应的class object中所有active virtual<br>functions函数实体的地址。这些active virtual function包括</p><ol><li>Class 所定义的函数实体，它会改写可能存在的base class virtual function函数实体。 </li><li>继承自base class的函数实体，即derived class没有改写这些function </li><li>一个pure_virtual_called()函数实体，可以包括pure virtual function或者异常处理，一旦执行pure_virtual_called()，会停止并退出。 </li></ol><p>例</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">virtual</span> Point<span class="token operator">&amp;</span> <span class="token function">mult</span><span class="token punctuation">(</span> <span class="token keyword">float</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">float</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>     <span class="token keyword">virtual</span> <span class="token keyword">float</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>     <span class="token keyword">virtual</span> <span class="token keyword">float</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token function">Print</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">float</span> _x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </code></pre><p>其中 virtual destructor赋值slot1,<br>mult()由于是纯虚函数，被pure_virtual_called()代替放在slot2。x()不是virtual function，不会放在slot中</p><p><img src="https://pic4.zhimg.com/v2-7b5e7de84688b146332d80c7cbb5db77_b.jpg" loading="lazy"></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point2d</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Point</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Point2d</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span>         <span class="token operator">:</span> <span class="token function">Point</span><span class="token punctuation">(</span> x <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>     <span class="token operator">~</span><span class="token function">Point2d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//改写base class virtual functions </span>    Point2d<span class="token operator">&amp;</span> <span class="token function">mult</span><span class="token punctuation">(</span> <span class="token keyword">float</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">float</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">float</span> _y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p><img src="https://pic3.zhimg.com/v2-525e254e78364fc1319d3583296636c2_b.jpg" loading="lazy"></p><p>在base class Point基础上，Point2d修改了~Point2d(), mult(), y()并拷贝到derive class的virtual<br>table对应的位置上。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point3d</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Point2d</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Point3d</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> z <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span>         <span class="token operator">:</span> <span class="token function">Point2d</span><span class="token punctuation">(</span> x<span class="token punctuation">,</span> y <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>     <span class="token operator">~</span><span class="token function">Point3d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//改写base class virtual functions </span>    Point3d<span class="token operator">&amp;</span> <span class="token function">mult</span><span class="token punctuation">(</span> <span class="token keyword">float</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">float</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _z<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">float</span> _z<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p><img src="https://pic1.zhimg.com/v2-aa34702f88abdc2df6dfb9d3277ae544_b.jpg" loading="lazy"></p><p>在继承下，如果有ptr-&gt;z()。我们不知道ptr所指对象的真正类型，但是：</p><ol><li><p>可以经由ptr获取virtual table </p></li><li><p>每个z()函数都会放在slot4</p></li></ol><p>以上信息， <strong>编译器可以将该调用转化为</strong> ( *ptr-&gt; vptr[4] )(ptr)。至于ptr具体类型执行期判断即可，但无论如何( *ptr-&gt;<br>vptr[4] )(ptr)总会得到想要的ptr-&gt;z()。</p><h3 id="Inline-函数"><a href="#Inline-函数" class="headerlink" title="Inline 函数"></a>Inline 函数</h3><p>inline函数执行成本比一般函数调用及返回机制带来的负荷低。处理一个inline函数有两个阶段</p><ol><li>分析函数定义，决定函数本质特征。若函数被判断不能成为inline，会被转换成一个static函数。 </li><li>inline函数扩展操作，会带来参数求值以及临时对象的管理。 </li></ol><p>inline在执行时，每个形式参数会被实际参数取代，例：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> i <span class="token operator">&lt;</span> j<span class="token operator">?</span> i <span class="token operator">:</span> j<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">//调用操作 </span><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> minval<span class="token punctuation">;</span>     <span class="token keyword">int</span> val1 <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> val2 <span class="token operator">=</span> <span class="token number">2048</span><span class="token punctuation">;</span>     minval <span class="token operator">=</span> <span class="token function">min</span> <span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//直接代换 minval = val1 &lt; val2 ? val1: val2; </span>    minval <span class="token operator">=</span> <span class="token function">min</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 代换之后得到minval = 1024; </span>    minval <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 需要导入临时对象，minval = ( t1=foo()),(t2=bar()+1), t1 &lt; t2? t1:t2 </span><span class="token punctuation">&#125;</span> </code></pre><p>注意到inline函数中如果存在局部变量，可能导致大量临时对象的产生。编写Inline函数时应该尽量写表达式形式，尽量少的使用内部对象，局部变量。</p>]]></content>
      
      
      <categories>
          
          <category> cpp对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp对象模型</title>
      <link href="/cpp%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/2021-01-15-1%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
      <url>/cpp%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/2021-01-15-1%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>C语言中，数据和处理数据的操作（函数)是分开声明的，不支持数据函数之间的关联性，称之为程序性的(procedural)。</p></blockquote><h3 id="1-对象类型"><a href="#1-对象类型" class="headerlink" title="1. 对象类型"></a>1. 对象类型</h3><span id="more"></span><p>C++中可以通过独立抽象数据类型实现。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point3d</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token function">Point3d</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> z <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span>      <span class="token keyword">float</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">float</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">float</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">private</span><span class="token operator">:</span>     <span class="token keyword">float</span> _x<span class="token punctuation">;</span>     <span class="token keyword">float</span> _y<span class="token punctuation">;</span>     <span class="token keyword">float</span> _z<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 类外部inline函数 </span><span class="token keyword">inline</span> ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>opstream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Point3d <span class="token operator">&amp;</span>pt <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     os <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> pt<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> pt<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> pt<span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </code></pre><p>或以一个双层的class体系</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Point</span> <span class="token punctuation">(</span><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_x</span><span class="token punctuation">(</span> x <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">float</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>     <span class="token keyword">void</span> <span class="token function">x</span> <span class="token punctuation">(</span> <span class="token keyword">float</span> xval <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>_x <span class="token operator">=</span> xval<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token keyword">protected</span><span class="token operator">:</span>      <span class="token keyword">float</span> _x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">class</span> <span class="token class-name">Point2d</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Point</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Point2d</span><span class="token punctuation">(</span> <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Point</span><span class="token punctuation">(</span> x <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_y</span><span class="token punctuation">(</span> y <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">float</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _y <span class="token punctuation">&#125;</span>     <span class="token keyword">void</span> <span class="token function">y</span><span class="token punctuation">(</span> <span class="token keyword">float</span> yval <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> _y <span class="token operator">=</span> yval<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">float</span> _y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </code></pre><p>显然在C++中实现3D坐标点，比在C中复杂，尤其是在使用template的情况下。</p><p>加上了封装之后，布局成本增加了多少？答案是 <strong>没有增加成本</strong> ，像C struct的情况一样， member<br>function虽然含在class的声明之内，却不出现在object之中。每一个non-inline member<br>function只会产生一个函数实体（实体不属于对象，不增加对象空间）， inline<br>function则在每个模块身上产生一个函数实体（可看作表达式，直接嵌入到调用函数中，降低执行时间）。</p><p>C++在布局以及存取时间上主要的额外负担由vitual引起，包括</p><ul><li>Virtual function : 用于支持一个有效率的“执行其绑定” </li><li>Virtual function : 用以实现多重继承base class只有单一的实体存在于后代中。 </li></ul><p>没有理由说C++比C庞大而迟缓。</p><p>C++中，有两种class data member: <strong>static 和 nonstatic</strong> ，三种 class member functions:<br>static, nonstatic, virtual。</p><p>以下代码为例：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Point</span><span class="token punctuation">(</span> <span class="token keyword">float</span> xval<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">float</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>     <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">PointCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">virtual</span> ostream<span class="token operator">&amp;</span> <span class="token function">print</span> <span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>     <span class="token keyword">float</span> _x<span class="token punctuation">;</span>     <span class="token keyword">static</span> <span class="token keyword">int</span> _point_count<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p>C++对象模型中， Non-static data members配置在class object之内， static和 non-static<br>function member则放在class object之外。</p><ol><li>每个class产生一堆指向virtual function的指针，放在表格之中。该表格称为virtual table (vtbl)，注意只指向虚函数。 </li><li>每个class object被添加指针，指向virtual table，该指针称为vptr。vptr的设置，重置都由class的constructor, destructor, copy assignment运算符自动完成。每个class关联的type_info object（用以支持RTTI)也经由virtual table放在第一个slot处。 </li></ol><p><img src="../assets/images/2021-1-6/1.jpg" alt="avatar" loading="lazy"></p><p>C++中，多态只存在于public<br>class体系中，即对象指针px可能指向自我类型的一个object，或指向public派生而来的一个类型。Nonpublic的派生行为并没有被语言明白地的支持，往往需要通过转型操作来管理。<br>多态的实现方式如下：</p><ol><li>经过一组隐含的转化操作，例如把一个derived class指针转化为一个指向其public base type的指针: shape *ps = new circle; </li><li>经由virtual function机制： ps -&gt; rotate(); </li><li>经由dynamic_case转型 if (circle *pc = dynamic_cast&lt; circle *&gt; (ps) ) </li></ol><p>例</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span> X datum<span class="token punctuation">,</span> <span class="token keyword">const</span> X <span class="token operator">*</span>pointer<span class="token punctuation">,</span> <span class="token keyword">const</span> X <span class="token operator">&amp;</span>reference <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 注意： (*pointer)，reference在运行期之前无法确定调用rotate()的对象类型，可以是X类型，也可以是派生类型 </span>    <span class="token comment">// 本例中调Z.rotate()，显然Z应是X的派生类型。  </span>    <span class="token punctuation">(</span><span class="token operator">*</span>pointer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     reference<span class="token punctuation">.</span><span class="token function">rotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// datum.rotate(); 必然是X类型的.rotate() </span>    datum<span class="token punctuation">.</span><span class="token function">rotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     Z z<span class="token punctuation">;</span>     <span class="token function">rotate</span><span class="token punctuation">(</span> z<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><h3 id="2-指针类型"><a href="#2-指针类型" class="headerlink" title="2. 指针类型"></a>2. 指针类型</h3><p> <strong>指针的类型，表征为指针的涵盖地址范围</strong><br>。例如一个指向地址1000的整数指针，32机器上int占4个字节。所以指针涵盖地址空间1000~1003。而void*<br>指针只能含有一个地址没有指定地址空间，因此不能对void*解指针操作object。</p><p>转型cast其实是一种编译器指令，大部分情况下不改变指针真正地址，只影响“指向内存大小和内容”的解释方式。对object定义指针必须要知道对象大小，作为指针的地址范围。这种情况往往会带了麻烦，例如编译依赖。</p><p>加上多态之后 、</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ZooAnimal</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">ZooAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">ZooAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">int</span> loc<span class="token punctuation">;</span>     string name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">class</span> <span class="token class-name">Bear</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">ZooAnimal</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Bear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">~</span><span class="token function">Bear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">dance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">protected</span><span class="token operator">:</span>     <span class="token keyword">enum</span> <span class="token class-name">Dances</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>     Dances dances_known<span class="token punctuation">;</span>     <span class="token keyword">int</span> cell_block<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  ZooAnimal <span class="token function">za</span><span class="token punctuation">(</span><span class="token string">"Zoey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ZooAnimal <span class="token operator">*</span>pza <span class="token operator">=</span> <span class="token operator">&amp;</span>za<span class="token punctuation">;</span>  Bear <span class="token function">b</span><span class="token punctuation">(</span><span class="token string">"Yogi"</span><span class="token punctuation">)</span> Bear <span class="token operator">*</span>pb <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> Bear <span class="token operator">*</span>rb <span class="token operator">=</span> <span class="token operator">*</span>pb<span class="token punctuation">;</span> </code></pre><p>ZooAnimal的object布局和pointer布局</p><p>注意到string是一个对象，成员包括String::len和char* String::str</p><p><img src="../assets/images/2021-1-6/2.jpg" alt="avatar" loading="lazy"></p><p><img src="../assets/images/2021-1-6/3.jpg" alt="avatar" loading="lazy"></p><p>其中前三项继承至ZooAnimal。而Bear指针和ZooAnimal指针都指向相同地址，即Bear<br>object的第一个字节。差别是pb涵盖地址范围包含整个bear object, pz只包含Bear object中的ZooAnimal部分。</p><p>此外，pz不能处理Bear独有members，唯一例外是通过virtual机制。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">pz<span class="token operator">-></span>cell_block<span class="token punctuation">;</span>  <span class="token comment">//不合法，pz范围到不了Bear独有成员 </span><span class="token punctuation">(</span><span class="token punctuation">(</span>Bear<span class="token operator">*</span> <span class="token punctuation">)</span>pz<span class="token punctuation">)</span> <span class="token operator">-></span> cellblock<span class="token punctuation">;</span>  <span class="token comment">// 经过一个downcast，改变指针范围，操作没问题 </span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Bear<span class="token operator">*</span> <span class="token punctuation">)</span>pb2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span> Bear<span class="token operator">*</span> <span class="token operator">></span></span></span><span class="token punctuation">(</span>pz<span class="token punctuation">)</span><span class="token punctuation">)</span>     pb2<span class="token operator">-></span>cell_block<span class="token punctuation">;</span> <span class="token comment">// 这个比较好，但作为run-time operation成本较高 </span> pb <span class="token operator">-></span> cell_block<span class="token punctuation">;</span> <span class="token comment">//这个ok </span></code></pre><p>注意到pointer或reference之所以支持多态，因为他们只是改变指向内存大小和解释方式。使用virtual的多态也称为OO（Object<br>oriented)操作，而不是用virtual称为OB(Object<br>based)。OO有弹性，但OB有效率，后者所有函数引发操作均在编译时期解析完成，且不需要承担支持virtual机制需要的额外负荷。</p><h3 id="Default-constructor"><a href="#Default-constructor" class="headerlink" title="Default constructor"></a>Default constructor</h3><p>编译器根据需要合成constructor，被合成的constructor只执行编译器所需的行动。这说明以下两点均错误（1）任何class如果没有定义default<br>constructor，就会被合成出一个来。（错误！！！按需合成）(2) 编译器合成出来的dafault<br>constructor会明确设定class内每一个data member的默认值 （错误，一般不会赋初值）</p><p>什么时候需要 <strong>合成default constructor</strong> ，有四种情况</p><ol><li>成员有 <strong>类对象(Member class object)，且该类对象有default construct。</strong></li></ol><p>例，</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Foo</span><span class="token punctuation">(</span> <span class="token keyword">int</span> <span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> Foo foo<span class="token punctuation">;</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">foo_bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     Bar bar<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span> </code></pre><p>执行Bar bar需要初始化Foo foo，但不会初始化Bar ::<br>str。因为为了保证运行，编译器需要初始化Bar::foo，但初始化Bar::str与否不影响运行，是程序员的责任。</p><p>为了保证程序正常运行，需要手工对str进行初始化。</p><p>2. 当一个没有constructor的class <strong>派生一个有default constructor的base class</strong> ，该derived<br>class的default constructor会被合成，且调用base class 的default constructor</p><p>3. 当class <strong>声明或继承一个virtual function</strong> 。会合成default<br>constructor，且下面两个扩张操作会在编译期间发生</p><ul><li>一个virtual function table (vtbl)会被编译器产生，内含class的virtual function地址 </li><li>每一个class object中，一个额外的pointer member (vptr)被编译器合成，内含class vtbl的地址。 </li></ul><p>4. 具有virtual base class的类。需要建立default constructor实现一些功能，例如执行期存取操作。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">X</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">X</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span> <span class="token operator">:</span> <span class="token keyword">double</span> d<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token keyword">int</span> k<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 无法编译期确定pa->X::i的位置，因为pa类型可以是A，也可以是C </span><span class="token keyword">void</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">*</span> pa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> pa <span class="token operator">-></span> i <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><h3 id="Copy-Constructor"><a href="#Copy-Constructor" class="headerlink" title="Copy Constructor"></a>Copy Constructor</h3><p>三种情况下，一个object的内容作为另一个class object的初值，导致拷贝构造函数的调用。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 第一种情况，明确赋值 </span><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> X x<span class="token punctuation">;</span> X xx <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 明确以object内容作为另一个object的初值 </span> <span class="token comment">// 第二种情况，当object作为实参交给形参时 </span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">foo</span> <span class="token punctuation">(</span>X x<span class="token punctuation">)</span><span class="token punctuation">;</span> X xx<span class="token punctuation">;</span> <span class="token function">foo</span><span class="token punctuation">(</span>xx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第三种情况 return 一个class object </span><span class="token function">foo_bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     X xx<span class="token punctuation">;</span>     <span class="token keyword">return</span> xx<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><p>并非所有对object赋值的情况都会导致拷贝构造，对于简单的情况会使用 <strong>Bitwise copy Semantic</strong><br>（位逐次拷贝），挨个变量赋值，并不生成default copy constructor。</p><p>与default constructor类似，有四种情况下需要合成default copy constructor:</p><ul><li>class内部有一个member object，且后者class声明有copy constructor。需生成default copy constructor实现member object赋值逻辑 </li><li>class继承一个base class, 且后者class声明有copy constructor。因为derived class包含 base class的成员。</li><li>class声明virtual function，因为需用copy constructor 对vtbl赋值 </li><li>class派生一个继承链，其中有virtual base class. </li></ul><h3 id="明确的初始化"><a href="#明确的初始化" class="headerlink" title="明确的初始化"></a>明确的初始化</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">X x0<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">foo_bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     X <span class="token function">x1</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span>     X x2 <span class="token operator">=</span> x0<span class="token punctuation">;</span>     X x3 <span class="token operator">=</span> <span class="token function">X</span><span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">//实际上调用 </span>X x1<span class="token punctuation">;</span> x1<span class="token punctuation">.</span><span class="token class-name">X</span><span class="token double-colon punctuation">::</span><span class="token function">X</span><span class="token punctuation">(</span> x0 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//表现为调用copy constructor X::X( const X&amp; xx ); </span><span class="token comment">// x2,x3亦然 </span></code></pre><p>一般的，在实参到形参，返回值时都会产生临时对象，用copy constructor赋值给临时对象。但有时编译器优化会跳过临时对象这步。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 优化前 </span>vector _temp0<span class="token punctuation">;</span> <span class="token function">add</span> <span class="token punctuation">(</span>_temp0，a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> vector <span class="token function">c</span><span class="token punctuation">(</span>_temp0<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 优化后 </span>vector c<span class="token punctuation">;</span> <span class="token function">add</span> <span class="token punctuation">(</span>c<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>成员初始化序列</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 如下这种风格最有效率 </span><span class="token class-name">Word</span><span class="token double-colon punctuation">::</span><span class="token function">Word</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_cnt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_name</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 不要这样写,显然会执行，创建临时对象，拷贝构造，析构临时对象 </span><span class="token function">Word</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     _name <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     _cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 上面代码等价于 </span>_name <span class="token punctuation">.</span><span class="token class-name">String</span><span class="token double-colon punctuation">::</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> String temp <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构建临时对象 </span>_name<span class="token punctuation">.</span>String<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span> temp <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//赋值 </span>temp<span class="token punctuation">.</span><span class="token class-name">String</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//摧毁临时对象 </span></code></pre><p>注意： <strong>list的次序按照class member声明次序决定，与initialization list的排列顺序无关。</strong></p><h4 id="对象方法调用过程"><a href="#对象方法调用过程" class="headerlink" title="对象方法调用过程"></a>对象方法调用过程</h4><p>当调用对象函数时, 对象不会入栈, 入栈的是this指针, 通过this指针找到对象方法。</p><p>调用类的成员函数时，可以通过查看this指针来查看具体是哪个对象在调用。<strong>This指针首先入栈，然后成员函数的参数从右向左进行入栈(实际参数)，最后函数返回地址入栈</strong>。形式参数已经保存在寄存器中。</p><p><img src="../assets/images/return_stack.png" alt="avatar" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> cpp对象模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
